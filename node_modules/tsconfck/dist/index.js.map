{"version":3,"sources":["../src/find.ts","../src/find-all.ts","../src/to-json.ts","../src/parse.ts","../src/util.ts","../src/find-native.ts","../src/parse-native.ts"],"sourcesContent":["import path from 'path';\nimport { promises as fs } from 'fs';\n\n/**\n * find the closest tsconfig.json file\n *\n * @param {string} filename - path to file to find tsconfig for (absolute or relative to cwd)\n * @param {TSConfckFindOptions} options - options\n * @returns {Promise<string>} absolute path to closest tsconfig.json\n */\nexport async function find(filename: string, options?: TSConfckFindOptions) {\n\tlet dir = path.dirname(path.resolve(filename));\n\tconst root = options?.root ? path.resolve(options.root) : null;\n\twhile (dir) {\n\t\tconst tsconfig = await tsconfigInDir(dir, options);\n\t\tif (tsconfig) {\n\t\t\treturn tsconfig;\n\t\t} else {\n\t\t\tif (root === dir) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst parent = path.dirname(dir);\n\t\t\tif (parent === dir) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdir = parent;\n\t\t\t}\n\t\t}\n\t}\n\tthrow new Error(`no tsconfig file found for ${filename}`);\n}\n\nasync function tsconfigInDir(dir: string, options?: TSConfckFindOptions): Promise<string | void> {\n\tconst tsconfig = path.join(dir, 'tsconfig.json');\n\tif (options?.tsConfigPaths) {\n\t\treturn options.tsConfigPaths.has(tsconfig) ? tsconfig : undefined;\n\t}\n\ttry {\n\t\tconst stat = await fs.stat(tsconfig);\n\t\tif (stat.isFile() || stat.isFIFO()) {\n\t\t\treturn tsconfig;\n\t\t}\n\t} catch (e) {\n\t\t// ignore does not exist error\n\t\tif (e.code !== 'ENOENT') {\n\t\t\tthrow e;\n\t\t}\n\t}\n}\n\nexport interface TSConfckFindOptions {\n\t/**\n\t * Set of known tsconfig file locations to use instead of scanning the file system\n\t *\n\t * This is better for performance in projects like vite where find is called frequently but tsconfig locations rarely change\n\t * You can use `findAll` to build this\n\t */\n\ttsConfigPaths?: Set<string>;\n\n\t/**\n\t * project root dir, does not continue scanning outside of this directory.\n\t *\n\t * Improves performance but may lead to different results from native typescript when no tsconfig is found inside root\n\t */\n\troot?: string;\n}\n","import path from 'path';\nimport { Dirent, readdir } from 'fs';\n\ninterface WalkState {\n\tfiles: string[];\n\tcalls: number;\n\t// eslint-disable-next-line no-unused-vars\n\tskip?: (dir: string) => boolean;\n\terr: boolean;\n}\n\nconst sep = path.sep;\n\n/**\n * find all tsconfig.json files in dir\n *\n * @param {string} dir - path to dir (absolute or relative to cwd)\n * @param {TSConfckFindAllOptions} options - options\n * @returns {Promise<string[]>} list of absolute paths to all found tsconfig.json files\n */\nexport async function findAll(dir: string, options?: TSConfckFindAllOptions): Promise<string[]> {\n\tconst state: WalkState = {\n\t\tfiles: [],\n\t\tcalls: 0,\n\t\tskip: options?.skip,\n\t\terr: false\n\t};\n\treturn new Promise((resolve, reject) => {\n\t\twalk(path.resolve(dir), state, (err, files) => (err ? reject(err) : resolve(files!)));\n\t});\n}\n\nfunction walk(\n\tdir: string,\n\tstate: WalkState,\n\t// eslint-disable-next-line no-unused-vars\n\tdone: (err: NodeJS.ErrnoException | null, files?: string[]) => void\n) {\n\tif (state.err) {\n\t\treturn;\n\t}\n\tstate.calls++;\n\treaddir(dir, { withFileTypes: true }, (err, entries: Dirent[] = []) => {\n\t\tif (state.err) {\n\t\t\treturn;\n\t\t}\n\t\t// skip deleted or inaccessible directories\n\t\tif (err && !(err.code === 'ENOENT' || err.code === 'EACCES' || err.code === 'EPERM')) {\n\t\t\tstate.err = true;\n\t\t\tdone(err);\n\t\t} else {\n\t\t\tfor (const ent of entries) {\n\t\t\t\tif (ent.isDirectory() && !state.skip?.(ent.name)) {\n\t\t\t\t\twalk(`${dir}${sep}${ent.name}`, state, done);\n\t\t\t\t} else if (ent.isFile() && ent.name === 'tsconfig.json') {\n\t\t\t\t\tstate.files.push(`${dir}${sep}tsconfig.json`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (--state.calls === 0) {\n\t\t\t\tif (!state.err) {\n\t\t\t\t\tdone(null, state.files);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport interface TSConfckFindAllOptions {\n\t/**\n\t * helper to skip subdirectories when scanning for tsconfig.json\n\t *\n\t * eg ` dir => dir === 'node_modules' || dir === '.git'`\n\t */ // eslint-disable-next-line no-unused-vars\n\tskip?: (dir: string) => boolean;\n}\n","/*\n this file contains code from strip-bom and strip-json-comments by Sindre Sorhus\n https://github.com/sindresorhus/strip-json-comments/blob/v4.0.0/index.js\n https://github.com/sindresorhus/strip-bom/blob/v5.0.0/index.js\n licensed under MIT, see ../LICENSE\n*/\n\n/**\n * convert content of tsconfig.json to regular json\n *\n * @param {string} tsconfigJson - content of tsconfig.json\n * @returns {string} content as regular json, comments and dangling commas have been replaced with whitespace\n */\nexport function toJson(tsconfigJson: string): string {\n\tconst stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));\n\tif (stripped.trim() === '') {\n\t\t// only whitespace left after stripping, return empty object so that JSON.parse still works\n\t\treturn '{}';\n\t} else {\n\t\treturn stripped;\n\t}\n}\n\n/**\n * replace dangling commas from pseudo-json string with single space\n * implementation heavily inspired by strip-json-comments\n */\nfunction stripDanglingComma(pseudoJson: string) {\n\tlet insideString = false;\n\tlet offset = 0;\n\tlet result = '';\n\tlet danglingCommaPos = null;\n\tfor (let i = 0; i < pseudoJson.length; i++) {\n\t\tconst currentCharacter = pseudoJson[i];\n\t\tif (currentCharacter === '\"') {\n\t\t\tconst escaped = isEscaped(pseudoJson, i);\n\t\t\tif (!escaped) {\n\t\t\t\tinsideString = !insideString;\n\t\t\t}\n\t\t}\n\t\tif (insideString) {\n\t\t\tdanglingCommaPos = null;\n\t\t\tcontinue;\n\t\t}\n\t\tif (currentCharacter === ',') {\n\t\t\tdanglingCommaPos = i;\n\t\t\tcontinue;\n\t\t}\n\t\tif (danglingCommaPos) {\n\t\t\tif (currentCharacter === '}' || currentCharacter === ']') {\n\t\t\t\tresult += pseudoJson.slice(offset, danglingCommaPos) + ' ';\n\t\t\t\toffset = danglingCommaPos + 1;\n\t\t\t\tdanglingCommaPos = null;\n\t\t\t} else if (!currentCharacter.match(/\\s/)) {\n\t\t\t\tdanglingCommaPos = null;\n\t\t\t}\n\t\t}\n\t}\n\treturn result + pseudoJson.substring(offset);\n}\n\n// start strip-json-comments\nfunction isEscaped(jsonString: string, quotePosition: number) {\n\tlet index = quotePosition - 1;\n\tlet backslashCount = 0;\n\n\twhile (jsonString[index] === '\\\\') {\n\t\tindex -= 1;\n\t\tbackslashCount += 1;\n\t}\n\n\treturn Boolean(backslashCount % 2);\n}\n\nfunction strip(string: string, start?: number, end?: number) {\n\treturn string.slice(start, end).replace(/\\S/g, ' ');\n}\n\nconst singleComment = Symbol('singleComment');\nconst multiComment = Symbol('multiComment');\n\nfunction stripJsonComments(jsonString: string) {\n\tlet isInsideString = false;\n\tlet isInsideComment: false | symbol = false;\n\tlet offset = 0;\n\tlet result = '';\n\n\tfor (let index = 0; index < jsonString.length; index++) {\n\t\tconst currentCharacter = jsonString[index];\n\t\tconst nextCharacter = jsonString[index + 1];\n\n\t\tif (!isInsideComment && currentCharacter === '\"') {\n\t\t\tconst escaped = isEscaped(jsonString, index);\n\t\t\tif (!escaped) {\n\t\t\t\tisInsideString = !isInsideString;\n\t\t\t}\n\t\t}\n\n\t\tif (isInsideString) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!isInsideComment && currentCharacter + nextCharacter === '//') {\n\t\t\tresult += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = singleComment;\n\t\t\tindex++;\n\t\t} else if (isInsideComment === singleComment && currentCharacter + nextCharacter === '\\r\\n') {\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t} else if (isInsideComment === singleComment && currentCharacter === '\\n') {\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index);\n\t\t\toffset = index;\n\t\t} else if (!isInsideComment && currentCharacter + nextCharacter === '/*') {\n\t\t\tresult += jsonString.slice(offset, index);\n\t\t\toffset = index;\n\t\t\tisInsideComment = multiComment;\n\t\t\tindex++;\n\t\t} else if (isInsideComment === multiComment && currentCharacter + nextCharacter === '*/') {\n\t\t\tindex++;\n\t\t\tisInsideComment = false;\n\t\t\tresult += strip(jsonString, offset, index + 1);\n\t\t\toffset = index + 1;\n\t\t}\n\t}\n\n\treturn result + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));\n}\n// end strip-json-comments\n\n// start strip-bom\nfunction stripBom(string: string) {\n\t// Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n\t// conversion translates it to FEFF (UTF-16 BOM).\n\tif (string.charCodeAt(0) === 0xfeff) {\n\t\treturn string.slice(1);\n\t}\n\treturn string;\n}\n// end strip-bom\n","import path from 'path';\nimport { promises as fs } from 'fs';\nimport { createRequire } from 'module';\nimport { find, TSConfckFindOptions } from './find.js';\nimport { toJson } from './to-json.js';\nimport {\n\tnative2posix,\n\tresolve2posix,\n\tresolveReferencedTSConfigFiles,\n\tresolveSolutionTSConfig,\n\tresolveTSConfig\n} from './util';\n\n/**\n * parse the closest tsconfig.json file\n *\n * @param {string} filename - path to a tsconfig.json or a .ts source file (absolute or relative to cwd)\n * @param {TSConfckParseOptions} options - options\n * @returns {Promise<TSConfckParseResult>}\n * @throws {TSConfckParseError}\n */\nexport async function parse(\n\tfilename: string,\n\toptions?: TSConfckParseOptions\n): Promise<TSConfckParseResult> {\n\tconst cache = options?.cache;\n\tif (cache?.has(filename)) {\n\t\treturn cache.get(filename)!;\n\t}\n\tlet tsconfigFile;\n\tif (options?.resolveWithEmptyIfConfigNotFound) {\n\t\ttry {\n\t\t\ttsconfigFile = (await resolveTSConfig(filename)) || (await find(filename, options));\n\t\t} catch (e) {\n\t\t\tconst notFoundResult = {\n\t\t\t\ttsconfigFile: 'no_tsconfig_file_found',\n\t\t\t\ttsconfig: {}\n\t\t\t};\n\t\t\tcache?.set(filename, notFoundResult);\n\t\t\treturn notFoundResult;\n\t\t}\n\t} else {\n\t\ttsconfigFile = (await resolveTSConfig(filename)) || (await find(filename, options));\n\t}\n\tlet result;\n\tif (cache?.has(tsconfigFile)) {\n\t\tresult = cache.get(tsconfigFile)!;\n\t} else {\n\t\tresult = await parseFile(tsconfigFile, cache);\n\t\tawait Promise.all([parseExtends(result, cache), parseReferences(result, cache)]);\n\t\tcache?.set(tsconfigFile, result);\n\t}\n\tresult = resolveSolutionTSConfig(filename, result);\n\tcache?.set(filename, result);\n\treturn result;\n}\n\nasync function parseFile(\n\ttsconfigFile: string,\n\tcache?: Map<string, TSConfckParseResult>\n): Promise<TSConfckParseResult> {\n\tif (cache?.has(tsconfigFile)) {\n\t\treturn cache.get(tsconfigFile)!;\n\t}\n\ttry {\n\t\tconst tsconfigJson = await fs.readFile(tsconfigFile, 'utf-8');\n\t\tconst json = toJson(tsconfigJson);\n\t\tconst result = {\n\t\t\ttsconfigFile,\n\t\t\ttsconfig: normalizeTSConfig(JSON.parse(json), path.dirname(tsconfigFile))\n\t\t};\n\t\tcache?.set(tsconfigFile, result);\n\t\treturn result;\n\t} catch (e) {\n\t\tthrow new TSConfckParseError(\n\t\t\t`parsing ${tsconfigFile} failed: ${e}`,\n\t\t\t'PARSE_FILE',\n\t\t\ttsconfigFile,\n\t\t\te\n\t\t);\n\t}\n}\n\n/**\n * normalize to match the output of ts.parseJsonConfigFileContent\n *\n * @param tsconfig\n */\nfunction normalizeTSConfig(tsconfig: any, dir: string) {\n\t// set baseUrl to absolute path\n\tif (tsconfig.compilerOptions?.baseUrl && !path.isAbsolute(tsconfig.compilerOptions.baseUrl)) {\n\t\ttsconfig.compilerOptions.baseUrl = resolve2posix(dir, tsconfig.compilerOptions.baseUrl);\n\t}\n\treturn tsconfig;\n}\n\nasync function parseReferences(\n\tresult: TSConfckParseResult,\n\tcache?: Map<string, TSConfckParseResult>\n) {\n\tif (!result.tsconfig.references) {\n\t\treturn;\n\t}\n\tconst referencedFiles = resolveReferencedTSConfigFiles(result);\n\tconst referenced = await Promise.all(referencedFiles.map((file) => parseFile(file, cache)));\n\tawait Promise.all(referenced.map((ref) => parseExtends(ref, cache)));\n\tresult.referenced = referenced;\n}\n\nasync function parseExtends(result: TSConfckParseResult, cache?: Map<string, TSConfckParseResult>) {\n\tif (!result.tsconfig.extends) {\n\t\treturn;\n\t}\n\t// use result as first element in extended\n\t// but dereference tsconfig so that mergeExtended can modify the original without affecting extended[0]\n\tconst extended: TSConfckParseResult[] = [\n\t\t{ tsconfigFile: result.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result.tsconfig)) }\n\t];\n\n\t// flatten extends graph into extended\n\tlet pos = 0;\n\tconst extendsPath: string[] = [];\n\tlet currentBranchDepth = 0;\n\twhile (pos < extended.length) {\n\t\tconst extending = extended[pos];\n\t\textendsPath.push(extending.tsconfigFile);\n\t\tif (extending.tsconfig.extends) {\n\t\t\t// keep following this branch\n\t\t\tcurrentBranchDepth += 1;\n\t\t\tlet resolvedExtends: string[];\n\t\t\tif (!Array.isArray(extending.tsconfig.extends)) {\n\t\t\t\tresolvedExtends = [resolveExtends(extending.tsconfig.extends, extending.tsconfigFile)];\n\t\t\t} else {\n\t\t\t\t// reverse because typescript 5.0 treats ['a','b','c'] as c extends b extends a\n\t\t\t\tresolvedExtends = extending.tsconfig.extends\n\t\t\t\t\t.reverse()\n\t\t\t\t\t.map((ex: string) => resolveExtends(ex, extending.tsconfigFile));\n\t\t\t}\n\n\t\t\tconst circularExtends = resolvedExtends.find((tsconfigFile) =>\n\t\t\t\textendsPath.includes(tsconfigFile)\n\t\t\t);\n\t\t\tif (circularExtends) {\n\t\t\t\tconst circle = extendsPath.concat([circularExtends]).join(' -> ');\n\t\t\t\tthrow new TSConfckParseError(\n\t\t\t\t\t`Circular dependency in \"extends\": ${circle}`,\n\t\t\t\t\t'EXTENDS_CIRCULAR',\n\t\t\t\t\tresult.tsconfigFile\n\t\t\t\t);\n\t\t\t}\n\t\t\t// add new extends to the list directly after current\n\t\t\textended.splice(\n\t\t\t\tpos + 1,\n\t\t\t\t0,\n\t\t\t\t...(await Promise.all(resolvedExtends.map((file) => parseFile(file, cache))))\n\t\t\t);\n\t\t} else {\n\t\t\t// reached a leaf, backtrack to the last branching point and continue\n\t\t\textendsPath.splice(-currentBranchDepth);\n\t\t\tcurrentBranchDepth = 0;\n\t\t}\n\t\tpos = pos + 1;\n\t}\n\tresult.extended = extended;\n\t// skip first as it is the original config\n\tfor (const ext of result.extended!.slice(1)) {\n\t\textendTSConfig(result, ext);\n\t}\n}\n\nfunction resolveExtends(extended: string, from: string): string {\n\tlet error: any;\n\n\ttry {\n\t\treturn createRequire(from).resolve(extended);\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (!path.isAbsolute(extended) && !extended.startsWith('./') && !extended.startsWith('../')) {\n\t\ttry {\n\t\t\tconst fallbackExtended = path.join(extended, 'tsconfig.json');\n\t\t\treturn createRequire(from).resolve(fallbackExtended);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t}\n\t}\n\n\tthrow new TSConfckParseError(\n\t\t`failed to resolve \"extends\":\"${extended}\" in ${from}`,\n\t\t'EXTENDS_RESOLVE',\n\t\tfrom,\n\t\terror\n\t);\n}\n\n// references, extends and custom keys are not carried over\nconst EXTENDABLE_KEYS = [\n\t'compilerOptions',\n\t'files',\n\t'include',\n\t'exclude',\n\t'watchOptions',\n\t'compileOnSave',\n\t'typeAcquisition',\n\t'buildOptions'\n];\nfunction extendTSConfig(extending: TSConfckParseResult, extended: TSConfckParseResult): any {\n\tconst extendingConfig = extending.tsconfig;\n\tconst extendedConfig = extended.tsconfig;\n\tconst relativePath = native2posix(\n\t\tpath.relative(path.dirname(extending.tsconfigFile), path.dirname(extended.tsconfigFile))\n\t);\n\tfor (const key of Object.keys(extendedConfig).filter((key) => EXTENDABLE_KEYS.includes(key))) {\n\t\tif (key === 'compilerOptions') {\n\t\t\tif (!extendingConfig.compilerOptions) {\n\t\t\t\textendingConfig.compilerOptions = {};\n\t\t\t}\n\t\t\tfor (const option of Object.keys(extendedConfig.compilerOptions)) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {\n\t\t\t\t\tcontinue; // already set\n\t\t\t\t}\n\t\t\t\textendingConfig.compilerOptions[option] = rebaseRelative(\n\t\t\t\t\toption,\n\t\t\t\t\textendedConfig.compilerOptions[option],\n\t\t\t\t\trelativePath\n\t\t\t\t);\n\t\t\t}\n\t\t} else if (extendingConfig[key] === undefined) {\n\t\t\tif (key === 'watchOptions') {\n\t\t\t\textendingConfig.watchOptions = {};\n\t\t\t\tfor (const option of Object.keys(extendedConfig.watchOptions)) {\n\t\t\t\t\textendingConfig.watchOptions[option] = rebaseRelative(\n\t\t\t\t\t\toption,\n\t\t\t\t\t\textendedConfig.watchOptions[option],\n\t\t\t\t\t\trelativePath\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\textendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst REBASE_KEYS = [\n\t// root\n\t'files',\n\t'include',\n\t'exclude',\n\t// compilerOptions\n\t'baseUrl',\n\t'rootDir',\n\t'rootDirs',\n\t'typeRoots',\n\t'outDir',\n\t'outFile',\n\t'declarationDir',\n\t// watchOptions\n\t'excludeDirectories',\n\t'excludeFiles'\n];\n\ntype PathValue = string | string[];\n\nfunction rebaseRelative(key: string, value: PathValue, prependPath: string): PathValue {\n\tif (!REBASE_KEYS.includes(key)) {\n\t\treturn value;\n\t}\n\tif (Array.isArray(value)) {\n\t\treturn value.map((x) => rebasePath(x, prependPath));\n\t} else {\n\t\treturn rebasePath(value as string, prependPath);\n\t}\n}\n\nfunction rebasePath(value: string, prependPath: string): string {\n\tif (path.isAbsolute(value)) {\n\t\treturn value;\n\t} else {\n\t\t// relative paths use posix syntax in tsconfig\n\t\treturn path.posix.normalize(path.posix.join(prependPath, value));\n\t}\n}\n\nexport interface TSConfckParseOptions extends TSConfckFindOptions {\n\t/**\n\t * optional cache map to speed up repeated parsing with multiple files\n\t * it is your own responsibility to clear the cache if tsconfig files change during its lifetime\n\t * cache keys are input `filename` and absolute paths to tsconfig.json files\n\t *\n\t * You must not modify cached values.\n\t */\n\tcache?: Map<string, TSConfckParseResult>;\n\n\t/**\n\t * treat missing tsconfig as empty result instead of an error\n\t * parse resolves with { filename: 'no_tsconfig_file_found',tsconfig:{}} instead of reject with error\n\t */\n\tresolveWithEmptyIfConfigNotFound?: boolean;\n}\n\nexport interface TSConfckParseResult {\n\t/**\n\t * absolute path to parsed tsconfig.json\n\t */\n\ttsconfigFile: string;\n\n\t/**\n\t * parsed result, including merged values from extended\n\t */\n\ttsconfig: any;\n\n\t/**\n\t * ParseResult for parent solution\n\t */\n\tsolution?: TSConfckParseResult;\n\n\t/**\n\t * ParseResults for all tsconfig files referenced in a solution\n\t */\n\treferenced?: TSConfckParseResult[];\n\n\t/**\n\t * ParseResult for all tsconfig files\n\t *\n\t * [a,b,c] where a extends b and b extends c\n\t */\n\textended?: TSConfckParseResult[];\n}\n\nexport class TSConfckParseError extends Error {\n\tconstructor(message: string, code: string, tsconfigFile: string, cause?: Error) {\n\t\tsuper(message);\n\t\t// Set the prototype explicitly.\n\t\tObject.setPrototypeOf(this, TSConfckParseError.prototype);\n\t\tthis.name = TSConfckParseError.name;\n\t\tthis.code = code;\n\t\tthis.cause = cause;\n\t\tthis.tsconfigFile = tsconfigFile;\n\t}\n\n\t/**\n\t * error code\n\t */\n\tcode: string;\n\t/**\n\t * the cause of this error\n\t */\n\tcause: Error | undefined;\n\n\t/**\n\t * absolute path of tsconfig file where the error happened\n\t */\n\ttsconfigFile: string;\n}\n","import path from 'path';\nimport { promises as fs } from 'fs';\nimport { TSConfckParseResult } from './parse.js';\n\nconst POSIX_SEP_RE = new RegExp('\\\\' + path.posix.sep, 'g');\nconst NATIVE_SEP_RE = new RegExp('\\\\' + path.sep, 'g');\nconst PATTERN_REGEX_CACHE = new Map<string, RegExp>();\nconst GLOB_ALL_PATTERN = `**/*`;\nconst DEFAULT_EXTENSIONS = ['.ts', '.tsx', '.mts', '.cts'];\nconst DEFAULT_EXTENSIONS_RE_GROUP = `\\\\.(?:${DEFAULT_EXTENSIONS.map((ext) => ext.substring(1)).join(\n\t'|'\n)})`;\n// hide dynamic import from ts transform to prevent it turning into a require\n// see https://github.com/microsoft/TypeScript/issues/43329#issuecomment-811606238\nconst dynamicImportDefault = new Function('path', 'return import(path).then(m => m.default)');\n\nexport async function loadTS(): Promise<any> {\n\ttry {\n\t\treturn dynamicImportDefault('typescript');\n\t} catch (e) {\n\t\tconsole.error('typescript must be installed to use \"native\" functions');\n\t\tthrow e;\n\t}\n}\n\nexport async function resolveTSConfig(filename: string): Promise<string | void> {\n\tif (path.extname(filename) !== '.json') {\n\t\treturn;\n\t}\n\tconst tsconfig = path.resolve(filename);\n\ttry {\n\t\tconst stat = await fs.stat(tsconfig);\n\t\tif (stat.isFile() || stat.isFIFO()) {\n\t\t\treturn tsconfig;\n\t\t}\n\t} catch (e) {\n\t\t// ignore does not exist error\n\t\tif (e.code !== 'ENOENT') {\n\t\t\tthrow e;\n\t\t}\n\t}\n\tthrow new Error(`no tsconfig file found for ${filename}`);\n}\n\n/**\n * convert posix separator to native separator\n *\n * eg.\n * windows: C:/foo/bar -> c:\\foo\\bar\n * linux: /foo/bar -> /foo/bar\n *\n * @param filename {string} filename with posix separators\n * @returns {string} filename with native separators\n */\nexport function posix2native(filename: string) {\n\treturn path.posix.sep !== path.sep && filename.includes(path.posix.sep)\n\t\t? filename.replace(POSIX_SEP_RE, path.sep)\n\t\t: filename;\n}\n\n/**\n * convert native separator to posix separator\n *\n * eg.\n * windows: C:\\foo\\bar -> c:/foo/bar\n * linux: /foo/bar -> /foo/bar\n *\n * @param filename {string} filename with native separators\n * @returns {string} filename with posix separators\n */\nexport function native2posix(filename: string) {\n\treturn path.posix.sep !== path.sep && filename.includes(path.sep)\n\t\t? filename.replace(NATIVE_SEP_RE, path.posix.sep)\n\t\t: filename;\n}\n\n/**\n * converts params to native separator, resolves path and converts native back to posix\n *\n * needed on windows to handle posix paths in tsconfig\n *\n * @param dir {string} directory to resolve from\n * @param filename {string} filename or pattern to resolve\n */\nexport function resolve2posix(dir: string | null, filename: string) {\n\tif (path.sep === path.posix.sep) {\n\t\treturn dir ? path.resolve(dir, filename) : path.resolve(filename);\n\t}\n\treturn native2posix(\n\t\tdir\n\t\t\t? path.resolve(posix2native(dir), posix2native(filename))\n\t\t\t: path.resolve(posix2native(filename))\n\t);\n}\n\nexport function resolveReferencedTSConfigFiles(result: TSConfckParseResult): string[] {\n\tconst dir = path.dirname(result.tsconfigFile);\n\treturn result.tsconfig.references.map((ref: { path: string }) => {\n\t\tconst refPath = ref.path.endsWith('.json') ? ref.path : path.join(ref.path, 'tsconfig.json');\n\t\treturn resolve2posix(dir, refPath);\n\t});\n}\n\nexport function resolveSolutionTSConfig(\n\tfilename: string,\n\tresult: TSConfckParseResult\n): TSConfckParseResult {\n\tif (\n\t\tresult.referenced &&\n\t\tDEFAULT_EXTENSIONS.some((ext) => filename.endsWith(ext)) &&\n\t\t!isIncluded(filename, result)\n\t) {\n\t\tconst solutionTSConfig = result.referenced.find((referenced) =>\n\t\t\tisIncluded(filename, referenced)\n\t\t);\n\t\tif (solutionTSConfig) {\n\t\t\treturn {\n\t\t\t\t...solutionTSConfig,\n\t\t\t\tsolution: result\n\t\t\t};\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction isIncluded(filename: string, result: TSConfckParseResult): boolean {\n\tconst dir = native2posix(path.dirname(result.tsconfigFile));\n\tconst files = (result.tsconfig.files || []).map((file: string) => resolve2posix(dir, file));\n\tconst absoluteFilename = resolve2posix(null, filename);\n\tif (files.includes(filename)) {\n\t\treturn true;\n\t}\n\tconst isIncluded = isGlobMatch(\n\t\tabsoluteFilename,\n\t\tdir,\n\t\tresult.tsconfig.include || (result.tsconfig.files ? [] : [GLOB_ALL_PATTERN])\n\t);\n\tif (isIncluded) {\n\t\tconst isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || []);\n\t\treturn !isExcluded;\n\t}\n\treturn false;\n}\n\n/**\n * test filenames agains glob patterns in tsconfig\n *\n * @param filename {string} posix style abolute path to filename to test\n * @param dir {string} posix style absolute path to directory of tsconfig containing patterns\n * @param patterns {string[]} glob patterns to match against\n * @returns {boolean} true when at least one pattern matches filename\n */\nexport function isGlobMatch(filename: string, dir: string, patterns: string[]): boolean {\n\treturn patterns.some((pattern) => {\n\t\t// filename must end with part of pattern that comes after last wildcard\n\t\tlet lastWildcardIndex = pattern.length;\n\t\tlet hasWildcard = false;\n\t\tfor (let i = pattern.length - 1; i > -1; i--) {\n\t\t\tif (pattern[i] === '*' || pattern[i] === '?') {\n\t\t\t\tlastWildcardIndex = i;\n\t\t\t\thasWildcard = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// if pattern does not end with wildcard, filename must end with pattern after last wildcard\n\t\tif (\n\t\t\tlastWildcardIndex < pattern.length - 1 &&\n\t\t\t!filename.endsWith(pattern.slice(lastWildcardIndex + 1))\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if pattern ends with *, filename must end with a default extension\n\t\tif (pattern.endsWith('*') && !DEFAULT_EXTENSIONS.some((ext) => filename.endsWith(ext))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// for **/* , filename must start with the dir\n\t\tif (pattern === GLOB_ALL_PATTERN) {\n\t\t\treturn filename.startsWith(`${dir}/`);\n\t\t}\n\n\t\tconst resolvedPattern = resolve2posix(dir, pattern);\n\n\t\t// filename must start with part of pattern that comes before first wildcard\n\t\tlet firstWildcardIndex = -1;\n\t\tfor (let i = 0; i < resolvedPattern.length; i++) {\n\t\t\tif (resolvedPattern[i] === '*' || resolvedPattern[i] === '?') {\n\t\t\t\tfirstWildcardIndex = i;\n\t\t\t\thasWildcard = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tfirstWildcardIndex > 1 &&\n\t\t\t!filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// if no wildcard in pattern, filename must be equal to resolved pattern\n\t\tif (!hasWildcard) {\n\t\t\treturn filename === resolvedPattern;\n\t\t}\n\n\t\t// complex pattern, use regex to check it\n\t\tif (PATTERN_REGEX_CACHE.has(resolvedPattern)) {\n\t\t\treturn PATTERN_REGEX_CACHE.get(resolvedPattern)!.test(filename);\n\t\t}\n\t\tconst regex = pattern2regex(resolvedPattern);\n\t\tPATTERN_REGEX_CACHE.set(resolvedPattern, regex);\n\t\treturn regex.test(filename);\n\t});\n}\n\nfunction pattern2regex(resolvedPattern: string): RegExp {\n\tlet regexStr = '^';\n\tfor (let i = 0; i < resolvedPattern.length; i++) {\n\t\tconst char = resolvedPattern[i];\n\t\tif (char === '?') {\n\t\t\tregexStr += '[^\\\\/]';\n\t\t\tcontinue;\n\t\t}\n\t\tif (char === '*') {\n\t\t\tif (resolvedPattern[i + 1] === '*' && resolvedPattern[i + 2] === '/') {\n\t\t\t\ti += 2;\n\t\t\t\tregexStr += '(?:[^\\\\/]*\\\\/)*'; // zero or more path segments\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tregexStr += '[^\\\\/]*';\n\t\t\tcontinue;\n\t\t}\n\t\tif ('/.+^${}()|[]\\\\'.includes(char)) {\n\t\t\tregexStr += `\\\\`;\n\t\t}\n\t\tregexStr += char;\n\t}\n\n\t// add known file endings if pattern ends on *\n\tif (resolvedPattern.endsWith('*')) {\n\t\tregexStr += DEFAULT_EXTENSIONS_RE_GROUP;\n\t}\n\tregexStr += '$';\n\n\treturn new RegExp(regexStr);\n}\n","import path from 'path';\nimport { loadTS } from './util.js';\n\n/**\n * find the closest tsconfig.json file using native ts.findConfigFile\n *\n * You must have `typescript` installed to use this\n *\n * @param {string} filename - path to file to find tsconfig for (absolute or relative to cwd)\n * @returns {Promise<string>} absolute path to closest tsconfig.json\n */\nexport async function findNative(filename: string): Promise<string> {\n\tconst ts = await loadTS();\n\tconst { findConfigFile, sys } = ts;\n\tconst tsconfigFile = findConfigFile(path.dirname(path.resolve(filename)), sys.fileExists);\n\tif (!tsconfigFile) {\n\t\tthrow new Error(`no tsconfig file found for ${filename}`);\n\t}\n\treturn tsconfigFile;\n}\n","import path from 'path';\nimport {\n\tloadTS,\n\tnative2posix,\n\tresolveReferencedTSConfigFiles,\n\tresolveSolutionTSConfig,\n\tresolveTSConfig\n} from './util';\nimport { findNative } from './find-native';\n\n/**\n * parse the closest tsconfig.json file with typescript native functions\n *\n * You need to have `typescript` installed to use this\n *\n * @param {string} filename - path to a tsconfig.json or a .ts source file (absolute or relative to cwd)\n * @param {TSConfckParseNativeOptions} options - options\n * @returns {Promise<TSConfckParseNativeResult>}\n * @throws {TSConfckParseNativeError}\n */\nexport async function parseNative(\n\tfilename: string,\n\toptions?: TSConfckParseNativeOptions\n): Promise<TSConfckParseNativeResult> {\n\tconst cache = options?.cache;\n\tif (cache?.has(filename)) {\n\t\treturn cache.get(filename)!;\n\t}\n\tlet tsconfigFile;\n\n\tif (options?.resolveWithEmptyIfConfigNotFound) {\n\t\ttry {\n\t\t\ttsconfigFile = await resolveTSConfig(filename);\n\t\t\tif (!tsconfigFile) {\n\t\t\t\ttsconfigFile = await findNative(filename);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconst notFoundResult = {\n\t\t\t\ttsconfigFile: 'no_tsconfig_file_found',\n\t\t\t\ttsconfig: {},\n\t\t\t\tresult: null\n\t\t\t};\n\t\t\tcache?.set(filename, notFoundResult);\n\t\t\treturn notFoundResult;\n\t\t}\n\t} else {\n\t\ttsconfigFile = await resolveTSConfig(filename);\n\t\tif (!tsconfigFile) {\n\t\t\ttsconfigFile = await findNative(filename);\n\t\t}\n\t}\n\n\tlet result: TSConfckParseNativeResult;\n\tif (cache?.has(tsconfigFile)) {\n\t\tresult = cache.get(tsconfigFile)!;\n\t} else {\n\t\tconst ts = await loadTS();\n\t\tresult = await parseFile(tsconfigFile, ts, options);\n\t\tawait parseReferences(result, ts, options);\n\t\tcache?.set(tsconfigFile, result);\n\t}\n\n\t//@ts-ignore\n\tresult = resolveSolutionTSConfig(filename, result);\n\t//@ts-ignore\n\tcache?.set(filename, result);\n\treturn result;\n}\n\nasync function parseFile(\n\ttsconfigFile: string,\n\tts: any,\n\toptions?: TSConfckParseNativeOptions\n): Promise<TSConfckParseNativeResult> {\n\tconst cache = options?.cache;\n\tif (cache?.has(tsconfigFile)) {\n\t\treturn cache.get(tsconfigFile)!;\n\t}\n\tconst posixTSConfigFile = native2posix(tsconfigFile);\n\tconst { parseJsonConfigFileContent, readConfigFile, sys } = ts;\n\tconst { config, error } = readConfigFile(posixTSConfigFile, sys.readFile);\n\tif (error) {\n\t\tthrow new TSConfckParseNativeError(error, tsconfigFile, null);\n\t}\n\n\tconst host = {\n\t\tuseCaseSensitiveFileNames: false,\n\t\treadDirectory: sys.readDirectory,\n\t\tfileExists: sys.fileExists,\n\t\treadFile: sys.readFile\n\t};\n\n\tif (options?.ignoreSourceFiles) {\n\t\tconfig.files = [];\n\t\tconfig.include = [];\n\t}\n\tconst nativeResult = parseJsonConfigFileContent(\n\t\tconfig,\n\t\thost,\n\t\tpath.dirname(posixTSConfigFile),\n\t\tundefined,\n\t\tposixTSConfigFile\n\t);\n\tcheckErrors(nativeResult, tsconfigFile);\n\n\tconst result: TSConfckParseNativeResult = {\n\t\ttsconfigFile,\n\t\ttsconfig: result2tsconfig(nativeResult, ts),\n\t\tresult: nativeResult\n\t};\n\tcache?.set(tsconfigFile, result);\n\treturn result;\n}\n\nasync function parseReferences(\n\tresult: TSConfckParseNativeResult,\n\tts: any,\n\toptions?: TSConfckParseNativeOptions\n) {\n\tif (!result.tsconfig.references) {\n\t\treturn;\n\t}\n\tconst referencedFiles = resolveReferencedTSConfigFiles(result);\n\tresult.referenced = await Promise.all(\n\t\treferencedFiles.map((file) => parseFile(file, ts, options))\n\t);\n}\n\n/**\n * check errors reported by parseJsonConfigFileContent\n *\n * ignores errors related to missing input files as these may happen regularly in programmatic use\n * and do not affect the config itself\n *\n * @param {nativeResult} any - native typescript parse result to check for errors\n * @throws {TSConfckParseNativeError} for critical error\n */\nfunction checkErrors(nativeResult: any, tsconfigFile: string) {\n\tconst ignoredErrorCodes = [\n\t\t// see https://github.com/microsoft/TypeScript/blob/main/src/compiler/diagnosticMessages.json\n\t\t18002, // empty files list\n\t\t18003 // no inputs\n\t];\n\tconst criticalError = nativeResult.errors?.find(\n\t\t(error: TSDiagnosticError) => error.category === 1 && !ignoredErrorCodes.includes(error.code)\n\t);\n\tif (criticalError) {\n\t\tthrow new TSConfckParseNativeError(criticalError, tsconfigFile, nativeResult);\n\t}\n}\n\n/**\n * convert the result of `parseJsonConfigFileContent` to a tsconfig that can be parsed again\n *\n * - use merged compilerOptions\n * - strip prefix and postfix of compilerOptions.lib\n * - convert enum values back to string\n *\n * @param result\n * @param ts typescript\n * @returns {object} tsconfig with merged compilerOptions and enums restored to their string form\n */\nfunction result2tsconfig(result: any, ts: any) {\n\t// dereference result.raw so changes below don't modify original\n\tconst tsconfig = JSON.parse(JSON.stringify(result.raw));\n\t// for some reason the extended compilerOptions are not available in result.raw but only in result.options\n\t// and contain an extra fields 'configFilePath' and 'pathsBasePath'. Use everything but those 2\n\tconst ignoredOptions = ['configFilePath', 'pathsBasePath'];\n\tif (result.options && Object.keys(result.options).some((o) => !ignoredOptions.includes(o))) {\n\t\ttsconfig.compilerOptions = {\n\t\t\t...result.options\n\t\t};\n\t\tfor (const ignored of ignoredOptions) {\n\t\t\tdelete tsconfig.compilerOptions[ignored];\n\t\t}\n\t}\n\n\tconst compilerOptions = tsconfig.compilerOptions;\n\tif (compilerOptions) {\n\t\tif (compilerOptions.lib != null) {\n\t\t\t// remove lib. and .dts from lib.es2019.d.ts etc\n\t\t\tcompilerOptions.lib = compilerOptions.lib.map((x: string) =>\n\t\t\t\tx.replace(/^lib\\./, '').replace(/\\.d\\.ts$/, '')\n\t\t\t);\n\t\t}\n\t\tconst enumProperties = [\n\t\t\t{ name: 'importsNotUsedAsValues', enumeration: ts.ImportsNotUsedAsValues },\n\t\t\t{ name: 'module', enumeration: ts.ModuleKind },\n\t\t\t{\n\t\t\t\tname: 'moduleResolution',\n\t\t\t\tenumeration: {\n\t\t\t\t\t...ts.ModuleResolutionKind,\n\t\t\t\t\t2: 'node' /*ts.ModuleResolutionKind uses \"Node10\" but in tsconfig it is just node\"*/\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: 'newLine',\n\t\t\t\tenumeration: { 0: 'crlf', 1: 'lf' } /*ts.NewLineKind uses different names*/\n\t\t\t},\n\t\t\t{ name: 'target', enumeration: ts.ScriptTarget }\n\t\t];\n\t\tfor (const prop of enumProperties) {\n\t\t\tif (compilerOptions[prop.name] != null && typeof compilerOptions[prop.name] === 'number') {\n\t\t\t\tcompilerOptions[prop.name] = prop.enumeration[compilerOptions[prop.name]].toLowerCase();\n\t\t\t}\n\t\t}\n\t\tif (compilerOptions.target === 'latest') {\n\t\t\tcompilerOptions.target = 'esnext'; // why ts, why?\n\t\t}\n\t}\n\n\t// merged watchOptions\n\tif (result.watchOptions) {\n\t\ttsconfig.watchOptions = {\n\t\t\t...result.watchOptions\n\t\t};\n\t}\n\n\tconst watchOptions = tsconfig.watchOptions;\n\tif (watchOptions) {\n\t\tconst enumProperties = [\n\t\t\t{ name: 'watchFile', enumeration: ts.WatchFileKind },\n\t\t\t{ name: 'watchDirectory', enumeration: ts.WatchDirectoryKind },\n\t\t\t{ name: 'fallbackPolling', enumeration: ts.PollingWatchKind }\n\t\t];\n\t\tfor (const prop of enumProperties) {\n\t\t\tif (watchOptions[prop.name] != null && typeof watchOptions[prop.name] === 'number') {\n\t\t\t\tconst enumVal = prop.enumeration[watchOptions[prop.name]];\n\t\t\t\twatchOptions[prop.name] = enumVal.charAt(0).toLowerCase() + enumVal.slice(1);\n\t\t\t}\n\t\t}\n\t}\n\tif (tsconfig.compileOnSave === false) {\n\t\t// ts adds this property even if it isn't present in the actual config\n\t\t// delete if it is false to match content of tsconfig\n\t\tdelete tsconfig.compileOnSave;\n\t}\n\treturn tsconfig;\n}\n\nexport interface TSConfckParseNativeOptions {\n\t/**\n\t * optional cache map to speed up repeated parsing with multiple files\n\t * it is your own responsibility to clear the cache if tsconfig files change during its lifetime\n\t * cache keys are input `filename` and absolute paths to tsconfig.json files\n\t *\n\t * You must not modify cached values.\n\t */\n\tcache?: Map<string, TSConfckParseNativeResult>;\n\n\t/**\n\t * treat missing tsconfig as empty result instead of an error\n\t * parseNative resolves with { filename: 'no_tsconfig_file_found',tsconfig:{}, result: null} instead of reject with error\n\t */\n\tresolveWithEmptyIfConfigNotFound?: boolean;\n\n\t/**\n\t * Set this option to true to force typescript to ignore all source files.\n\t *\n\t * This is faster - especially for large projects - but comes with 2 caveats\n\t *\n\t * 1) output tsconfig always has `files: [],include: []` instead of any real values configured.\n\t * 2) as a result of 1), it won't be able to resolve solution-style references and always return the closest tsconfig\n\t */\n\tignoreSourceFiles?: boolean;\n}\n\nexport interface TSConfckParseNativeResult {\n\t/**\n\t * absolute path to parsed tsconfig.json\n\t */\n\ttsconfigFile: string;\n\n\t/**\n\t * parsed result, including merged values from extended and normalized\n\t */\n\ttsconfig: any;\n\n\t/**\n\t * ParseResult for parent solution\n\t */\n\tsolution?: TSConfckParseNativeResult;\n\n\t/**\n\t * ParseNativeResults for all tsconfig files referenced in a solution\n\t */\n\treferenced?: TSConfckParseNativeResult[];\n\n\t/**\n\t * full output of ts.parseJsonConfigFileContent\n\t */\n\tresult: any;\n}\n\nexport class TSConfckParseNativeError extends Error {\n\tconstructor(diagnostic: TSDiagnosticError, tsconfigFile: string, result?: any) {\n\t\tsuper(diagnostic.messageText);\n\t\t// Set the prototype explicitly.\n\t\tObject.setPrototypeOf(this, TSConfckParseNativeError.prototype);\n\t\tthis.name = TSConfckParseNativeError.name;\n\t\tthis.code = `TS ${diagnostic.code}`;\n\t\tthis.diagnostic = diagnostic;\n\t\tthis.result = result;\n\t\tthis.tsconfigFile = tsconfigFile;\n\t}\n\n\t/**\n\t * code of typescript diagnostic, prefixed with \"TS \"\n\t */\n\tcode: string;\n\n\t/**\n\t * full ts diagnostic that caused this error\n\t */\n\tdiagnostic: any;\n\n\t/**\n\t * absolute path of tsconfig file where the error happened\n\t */\n\ttsconfigFile: string;\n\n\t/**\n\t * native result if present, contains all errors in result.errors\n\t */\n\tresult: any | undefined;\n}\n\ninterface TSDiagnosticError {\n\tcode: number;\n\tcategory: number;\n\tmessageText: string;\n\tstart?: number;\n}\n"],"mappings":"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","names":["path","path","fs","path","fs","isIncluded","fs","path","key","path","path","path","parseFile","parseReferences","path"]}